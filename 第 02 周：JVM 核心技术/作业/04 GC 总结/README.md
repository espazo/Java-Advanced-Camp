## 不同 GC 和堆内存的总结

### 1，串行 GC，与并行 GC

串行与并行 GC 都是需要将 VM 内部的运行状态暂停一段时间的。那么在这一段时间内，会给应用造成无法响应的影响。但是相应的 GC 的 CPU 时间利用效率会更高，因为此时的 VM 在专心只做 VM 这一件事。

与串行和并行 GC 的比较。显然采用多线程的并行 GC 的效率是更加高效的，那么在这一种情况下串行 GC 有什么应用场景呢。有的，就是计算机不仅仅只跑一个应用，VM 应用需要跟计算机里其它应用和睦相处的时候，如果采用并行 GC 可能会对其它应用产生卡顿。

所以串行 GC，一般应用在单机的客户端应用，其本身的运行情况也更为简单，串行 GC 也足够应对了。

上面提到串行 GC 和 并行 GC 都是 GC 效率较高的 GC 之一。并行 GC 在
相关大吞吐率高的场景下便能大方异彩，一般会用在需要大的吞吐率但是对于实时性没有那么高的场景下。例如静态页面的 Web 服务器。

### 2，CMS GC 和 G1 类 GC

上面提到 `并行 GC` 可以用在实时性要求不是那么高的情况下。而一旦实时性的要求高了起来，那么 `并行 GC` 显然会在执行 `GC` 操作的时候会给 VM 带来较大的时间暂停。

如何让 VM 暂停的时间缩短，或者说在一个可控的时间范围之内呢。那既然`并行`行不通，那么就来一次 `并发` 吧。`并发` 就是在处理业务的同时进行 `GC` 的操作，这样虽然每次只垃圾回收一点点，虽然垃圾回收的效率没有那么高了，但是好在每次暂停的时间不会那么长。

> 当然了也不是说 `GC` 的操作可以完全不停止，因为如果 `VM` 不停止运行，就无法准确标记的。所以会在一开始的标记 `根节点` 和 `确认最终节点` 会暂停一下 `VM`，其它大部分工作都在并发的时候做完了。那么暂停的时间就是精简可控的。

当然啦，`CMS` 作为并发的 `GC`，就意味着只用了少数的线程做垃圾回收的工作，单也不是完全和 `VM` 里面的线程隔离了，`CMS` 仍旧会暂停过程中暂停 `VM` 跑的业务。

回想一下，这个是不是和 `串行 GC` 很像呢？是的，也就是说在垃圾的产生速度远远大于回收速度的时候，那么 `CMS GC` 会频繁启动。尽管每次暂停的时间不长，但是短时间频繁 `CMS GC` 其实也就和 `串行 GC` 无异了。也就是我们所说的“退化到了 `串行 GC`”。

与关于 `G1 GC` 呢，其实和 `CMS GC` 很像，也都是并发执行的，在最糟糕的情况下也会退化成 `串行 GC`，可以看作是 `CMS GC` 的升级版。

至于升级，是升级了什么地方呢？那就是堆内存的结构。

以前不管是 `串行 GC` 也好 `并行 GC` 也好，还是 `CMS GC`，它们用的都是同一套堆内存模型。也就是分成两个区域，大概 8 比 1 的样子，一个称为“新生代”区，另一个是“老年代”，存放着不同生命周期的对象。

而其中的堆管理流程呢，就是将新生代区进行划分：分为两个临时储存区 `S1` 和 `S2`，以及 `伊甸区`。一个应用在一段时间使用的内存，应当是有限的，不然多大的内存都会不够用。换句话说大部分占用过的内存，也是即将需要被清理的。那么新生的对象首先会进入 `伊甸区`，而这个区呢也注定会是清理的主要场地。

首先呢，我们会在 `伊甸区` 里找出还需要用的对象，当然啦通常情况下这是占少数的，然后复制到其中一个 `S` 区里。

> 有的同学要问了，这里为什么是 `复制` 而不是 `移动` 呢？其实呢，在计算机的世界里，`移动` 意味着两个操作分别是先 `复制` 后 `删除`，这显然要更慢一点。

这样呢，经过一次 `GC` 以后，我们把存活的对象都集中在了其中一个 `S` 区了。那么对于其它区呢，理所当然进行清空，这样就成功完成了一次 `GC` 了。

> 这里面还有一些细节没有讲到，但是呢有了我前面所讲的基础，其实自己就能够想到其它方面是如何处理的了。例如新生代里的两个 `S 区` 是如何交互的。新生代是如何进入老年代的，老年代是如何清理垃圾的（老年代里不分区）。只要稍加思索都能很容易想到。

那么讲到这里，细心的同学就很容易发现了一个致命的问题。那就是不管是并行还是并发处理垃圾，这个流程都太长了。当然啦一个完整的流程自然都是找出存活对象，然后再清空垃圾区，这个自然是不变的道理。

那为什么还说这个流程太长了呢，这时候我们就得想想是哪一个变量会影响这个流程呢？没错，就是清理内存区域的大小。随着技术的不断发展，我们的应用以及内存也越来越大，如果用了一个 `1T` 的内存，甚至说 `10T`，`100T` 的内存。这和我们 `8G` 的小内存内存相比，`VM` 暂停的时间总归会增长许多的。哪怕是再怎么并行，由于内存区域太大，`GC` 时对 `VM` 的内存也会越来越大，暂停的时间也越来越不可控。

而 `G1 GC` 呢，就是为了解决这个问题而来的。他摒弃了原本的堆内存模型，不在用两个大区区分老年代还是新生代。而是把整一个堆内存分许多个固定大小的一小块一小块。

每一小块呢也没有固定，可能是伊甸区，也可能是老年区。尽管 `GC` 的流程都是一样的：“找到存活对象，清空垃圾去”。但是由于每一小块的区都是很小的，那么 `G1 GC` 的每一次 `GC` 内存都是可控的。

这就大大减少了 `GC` 的暂停时间。当然咯，最差的情况下，也就是垃圾的产生速度远远超过 `GC` 的时候，不可避免的会退化成 `串行 GC`。

### 3，JVM 的分析和优化

有了上面对于每个 `GC` 工作原理，以及堆模型的知识。那么我们可以根据业务的需求，以及每种 `GC` 对于堆内存的掌控进行调优。

例如伊甸区的大小，老年代的大小，这些都是由业务开展的不同，会有业务不同的需要。对于 `G1 GC` 来说，每个分区不能过大也不能过小，过大的话会和 `CMS GC` 无异，过小的话容纳不了大的垃圾。

如果实在是难以分配其分区的大小，那么这个时候就得考虑优化其业务代码，把大的对象分解成一个个小的对象。

JVM 的参数非常多，在通常情况下，能够通过调参解决的问题。往往更加经济和实惠，其效果也会更加显著。可以通过更多的可视化分析工具，发现其中的问题。
